name: 'Reusable Terraform CI'

on:
  workflow_call:
    inputs:
      working_directory:
        description: 'Directory containing the Terraform root module'
        required: true
        type: string
        default: '.'
      tf_version:
        description: 'Terraform CLI version'
        required: false
        type: string
        default: 'latest'
      tfvars_file:
        description: 'Path to the .tfvars file (relative to working_directory)'
        required: false
        type: string
        default: ''
      tfbackend_file:
        description: 'Path to the .tfbackend file (relative to working_directory)'
        required: true # Make backend explicit for CI plans too
        type: string
      azure_credentials:
        description: 'Azure OIDC Credentials JSON object (client-id, tenant-id, subscription-id)'
        required: true
        type: string # Pass as JSON string from secrets
      backend_config_overrides:
        description: 'Optional backend config key=value pairs (JSON object string)'
        required: false
        type: string
        default: '{}' # e.g., '{ "resource_group_name": "override-rg", "key": "override.tfstate" }'

    secrets:
      AZURE_CREDENTIALS: # Define this secret in calling workflow/repo/env
        description: 'JSON object with { client-id, tenant-id, subscription-id }'
        required: true

# Permissions required for OIDC and PR commenting
permissions:
  id-token: write
  contents: read
  pull-requests: write

jobs:
  validate_and_plan:
    name: 'Terraform Validate & Plan'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ inputs.working_directory }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.tf_version }}
          terraform_wrapper: false # Keep it clean

      - name: Terraform Format Check
        id: fmt
        run: terraform fmt -check -recursive
        continue-on-error: false

      - name: Terraform Init (Validation)
        id: init_validate
        run: terraform init -backend=false # Purely syntax validation
        continue-on-error: false

      - name: Terraform Validate
        id: validate
        run: terraform validate
        continue-on-error: false

      - name: Azure Login using OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ fromJson(secrets.AZURE_CREDENTIALS).client-id }}
          tenant-id: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenant-id }}
          subscription-id: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscription-id }}
          enable-AzPSSession: false # Not needed for Terraform CLI

      - name: Terraform Init (with Backend)
        id: init
        run: |
          backend_args=""
          if [[ -n "${{ inputs.tfbackend_file }}" ]]; then
            backend_args="-backend-config=\"${{ inputs.tfbackend_file }}\""
          else
            echo "::warning::tfbackend_file input not provided. Relying on backend block in code or overrides."
          fi

          # Process JSON overrides object
          backend_overrides='${{ inputs.backend_config_overrides }}'
          if [[ "$backend_overrides" != "{}" ]]; then
            echo "Applying backend overrides..."
            # Use jq to iterate over the JSON object and build arguments
            echo "$backend_overrides" | jq -r 'to_entries[] | "-backend-config=\(.key)=\(.value)"' | while IFS= read -r line; do
              backend_args="$backend_args $line"
            done
          fi

          echo "Running: terraform init -input=false $backend_args"
          terraform init -input=false $backend_args
        env:
          # Set ARM env vars for Terraform Azure Provider (alternative to azure/login for provider auth if needed, but azure/login handles it)
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).client-id }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscription-id }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenant-id }}
          ARM_USE_OIDC: true

      - name: Terraform Plan
        id: plan
        run: |
          plan_args="-input=false -out=tfplan -detailed-exitcode"
          if [[ -n "${{ inputs.tfvars_file }}" ]]; then
            plan_args="$plan_args -var-file=${{ inputs.tfvars_file }}"
          fi

          # Run plan and capture exit code
          set +e # Allow command to fail without exiting script
          terraform plan $plan_args
          exitcode=$?
          set -e # Re-enable exit on error

          echo "Terraform Plan Exit Code: $exitcode"
          echo "exitcode=$exitcode" >> $GITHUB_OUTPUT

          if [ $exitcode -eq 1 ]; then
            echo "::error::Terraform Plan Failed!"
            exit 1
          elif [ $exitcode -eq 0 ]; then
             echo "Terraform Plan shows no changes."
          elif [ $exitcode -eq 2 ]; then
             echo "Terraform Plan shows changes."
          else
             echo "::error::Terraform Plan returned unexpected exit code $exitcode"
             exit 1
          fi
        env:
          # Pass TF_VARs if needed via environment variables (alternative to tfvars file)
          # Example: TF_VAR_location: ${{ inputs.location }} # Add 'location' input if needed
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).client-id }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscription-id }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenant-id }}
          ARM_USE_OIDC: true

      - name: Create Plan Output for Summary/PR Comment
        id: plan-output
        # Only run if plan succeeded (exit code 0 or 2)
        if: steps.plan.outputs.exitcode == '0' || steps.plan.outputs.exitcode == '2'
        run: |
          PLAN_OUTPUT=$(terraform show -no-color tfplan)
          # Escape special characters for markdown and multiline output
          PLAN_OUTPUT="${PLAN_OUTPUT//'%'/'%25'}"
          PLAN_OUTPUT="${PLAN_OUTPUT//$'\n'/'%0A'}"
          PLAN_OUTPUT="${PLAN_OUTPUT//$'\r'/'%0D'}"
          echo "plan_text<<EOF" >> $GITHUB_OUTPUT
          echo '```terraform' >> $GITHUB_OUTPUT
          terraform show -no-color tfplan >> $GITHUB_OUTPUT
          echo '```' >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # For PR Comment - shorter summary maybe? Or full plan. Let's do full plan in details tag.
          COMMENT_BODY="## Terraform Plan

          **Working Directory:** \`${{ inputs.working_directory }}\`
          **Plan Result:** $(if [ ${{ steps.plan.outputs.exitcode }} -eq 0 ]; then echo 'No Changes'; else echo 'Changes Detected'; fi)

          <details><summary>Click to expand Terraform Plan Output</summary>

          \`\`\`terraform
          $(terraform show -no-color tfplan)
          \`\`\`
          </details>"
          # Escape for JSON payload in github-script
          COMMENT_BODY="${COMMENT_BODY//'%'/'%25'}"
          COMMENT_BODY="${COMMENT_BODY//$'\n'/'%0A'}"
          COMMENT_BODY="${COMMENT_BODY//$'\r'/'%0D'}"
          echo "comment_body=$COMMENT_BODY" >> $GITHUB_OUTPUT

      - name: Publish Terraform Plan to Task Summary
        # Only run if plan succeeded (exit code 0 or 2)
        if: steps.plan.outputs.exitcode == '0' || steps.plan.outputs.exitcode == '2'
        env:
          PLAN_SUMMARY: ${{ steps.plan-output.outputs.plan_text }}
        run: |
          echo "## Terraform Plan Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Working Directory:** \`${{ inputs.working_directory }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Plan Result:** $(if [ ${{ steps.plan.outputs.exitcode }} -eq 0 ]; then echo 'No Changes'; else echo 'Changes Detected'; fi)" >> $GITHUB_STEP_SUMMARY
          echo "<details><summary>Click to expand Plan Output</summary>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${PLAN_SUMMARY}" >> $GITHUB_STEP_SUMMARY
          echo "</details>" >> $GITHUB_STEP_SUMMARY

      - name: Push Terraform Output to PR Comment
        # Only run on pull request events AND if plan succeeded
        if: github.event_name == 'pull_request' && (steps.plan.outputs.exitcode == '0' || steps.plan.outputs.exitcode == '2')
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const body = decodeURIComponent("${{ steps.plan-output.outputs.comment_body }}");
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });